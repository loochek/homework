#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

#include "../common/headers/lerror.h"
#include "../common/headers/prg.h"
#include "../common/headers/opcodes.h"
#include "../common/headers/arithm.h"

static inline uint8_t prg_read_byte(program_t *prg, size_t addr)
{
    return prg->code[addr];
}

static inline uint32_t prg_read_dword(program_t *prg, size_t addr)
{
    // SWCPU is little-endian
    uint32_t dword = prg->code[addr];
    dword |= prg->code[addr + 1] << 8;
    dword |= prg->code[addr + 2] << 16;
    dword |= prg->code[addr + 3] << 24;
    return dword;
}

int main()
{
    program_t *prg = load_program_from_file("discr.prg");
    if (prg == NULL)
    {
        LERRPRINT();
        return -1;
    }
    
    FILE *disassm_file = fopen("discr.assm", "w");
    if (disassm_file == NULL)
    {
        fprintf(stderr, "Can't open output file\n");
        return -1;
    }

    fprintf(disassm_file, "; Auto-generated by disassm\n"
                          "; Program %s\n", prg->prg_header->program_name);

    size_t pc = 0;
    while (pc < prg->prg_header->code_size)
    {
        char num_buf[21] = {0};

        uint8_t opcode = prg_read_byte(prg, pc);
        pc++;

        switch (opcode)
        {
        case OPCODE_NOP:
            fprintf(disassm_file, "nop\n");
            break;

        case OPCODE_PUSH_IMM:
            num_to_str(prg_read_dword(prg, pc), num_buf);
            pc += 4;
            fprintf(disassm_file, "push %s\n", num_buf);
            break;

        case OPCODE_PUSH_RAX:
            fprintf(disassm_file, "push rax\n");
            break;

        case OPCODE_PUSH_RBX:
            fprintf(disassm_file, "push rbx\n");
            break;
            
        case OPCODE_PUSH_RCX:
            fprintf(disassm_file, "push rcx\n");
            break;
            
        case OPCODE_PUSH_RDX:
            fprintf(disassm_file, "push rdx\n");
            break;
            
        case OPCODE_POP_RAX:
            fprintf(disassm_file, "pop rax\n");
            break;

        case OPCODE_POP_RBX:
            fprintf(disassm_file, "pop rbx\n");
            break;
            
        case OPCODE_POP_RCX:
            fprintf(disassm_file, "pop rcx\n");
            break;
            
        case OPCODE_POP_RDX:
            fprintf(disassm_file, "pop rdx\n");
            break;

        case OPCODE_IN:
            fprintf(disassm_file, "in\n");
            break;

        case OPCODE_OUT:
            fprintf(disassm_file, "out\n");
            break;

        case OPCODE_ADD:
            fprintf(disassm_file, "add\n");
            break;

        case OPCODE_SUB:
            fprintf(disassm_file, "sub\n");
            break;

        case OPCODE_MUL:
            fprintf(disassm_file, "mul\n");
            break;

        case OPCODE_DIV:
            fprintf(disassm_file, "div\n");
            break;

        case OPCODE_HLT:
            fprintf(disassm_file, "hlt\n");
            break;

        default:
            printf("Disassm fatal error: unknown opcode %02x\n", opcode);
            return 0;
            break;
        }
    }

    fclose(disassm_file);
    program_unload(prg);
    return 0;
}
