#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

#include "../common/headers/lerror.h"
#include "../common/headers/prg.h"
#include "../common/headers/arithm.h"
#include "../common/headers/global_constants.h"

static inline uint8_t prg_read_byte(size_t *pc, program_t *prg);
static inline double prg_read_double(size_t *pc, program_t *prg);
static void construct_argument(uint8_t arg_mask, size_t *pc, char* arg_buf, program_t *prg);

// INSTRUCTION definition for disassm
#define INSTRUCTION(MNEMONIC, BASE_OPCODE, ARG_TYPE, IMPL) \
case BASE_OPCODE:                                          \
{                                                          \
    fprintf(disassm_file, #MNEMONIC);                      \
    if (arg_mask != ARG_NONE)                              \
    {                                                      \
        char arg_buf[41] = {0};                            \
        construct_argument(arg_mask, &pc, arg_buf, prg);   \
        fprintf(disassm_file, " %s", arg_buf);             \
    }                                                      \
    fprintf(disassm_file, "\n");                           \
}                                                          \
break;

int main(int argc, char* argv[])
{
    char* src_file_name = "src.assm";
    char* prg_name      = NULL;
    if (argc < 2)
    {
        printf("Usage: disassm <input program file> [<output source file>]\n");
        return 0;
    }
    if (argc >= 2)
        prg_name      = argv[1];
    if (argc >= 3)
        src_file_name = argv[2];

    program_t *prg = load_program_from_file(prg_name);
    if (prg == NULL)
    {
        LERRPRINT();
        return -1;
    }
    
    FILE *disassm_file = fopen(src_file_name, "w");
    if (disassm_file == NULL)
    {
        fprintf(stderr, "Can't open output file\n");
        return -1;
    }

    fprintf(disassm_file, "; Auto-generated by disassm\n"
                          "; Program %s\n", prg->prg_header->program_name);

    size_t pc = 0;
    while (pc < prg->prg_header->code_size)
    {
        uint8_t opcode = prg_read_byte(&pc, prg);
        uint8_t arg_mask = opcode & 7;

        switch (opcode & 248) // 11111000
        {
        #include "../cpu_def.h"

        default:
            printf("Disassm fatal error: unknown base opcode %02x\n", opcode & 248);
            fclose(disassm_file);
            program_unload(prg);
            return 0;
        }
    }
    fclose(disassm_file);
    program_unload(prg);
    return 0;
}

static inline uint8_t prg_read_byte(size_t *pc, program_t *prg)
{ 
    return prg->code[(*pc)++];
}

static inline double prg_read_double(size_t *pc, program_t *prg)
{
    // SWCPU is little-endian
    uint64_t qword = (int64_t)prg->code[(*pc)++];
    qword |= (int64_t)prg->code[(*pc)++] << 8;
    qword |= (int64_t)prg->code[(*pc)++] << 16;
    qword |= (int64_t)prg->code[(*pc)++] << 24;
    qword |= (int64_t)prg->code[(*pc)++] << 32;
    qword |= (int64_t)prg->code[(*pc)++] << 40;
    qword |= (int64_t)prg->code[(*pc)++] << 48;
    qword |= (int64_t)prg->code[(*pc)++] << 56;
    double to_ret = 0;
    memcpy(&to_ret, &qword, sizeof(double));
    return to_ret;
}

static void construct_argument(uint8_t arg_mask, size_t *pc, char* arg_buf, program_t *prg)
{
    if ((arg_mask & ARG_MASK_RAM) != 0)
        strcat(arg_buf, "[");
    if ((arg_mask & ARG_MASK_REGISTER) != 0)
    {
        char reg_name[] = "r_x";
        reg_name[1] = 'a' + prg_read_byte(pc, prg);
        strcat(arg_buf, reg_name);
    }
    if ((arg_mask & ARG_MASK_REGISTER) != 0 && (arg_mask & ARG_MASK_IMMEDIATE) != 0)
        strcat(arg_buf, "+");
    if ((arg_mask & ARG_MASK_IMMEDIATE) != 0)
    {
        char num_buf[20] = {0};
        num_to_str(prg_read_double(pc, prg), num_buf);
        strcat(arg_buf, num_buf);
    }
    if ((arg_mask & ARG_MASK_RAM) != 0)
        strcat(arg_buf, "]");
}