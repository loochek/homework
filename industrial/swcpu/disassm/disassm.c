#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

#include "../common/headers/lerror.h"
#include "../common/headers/prg.h"
#include "../common/headers/arithm.h"
#include "../common/headers/global_constants.h"

static inline void    disassm           (program_t *prg, const char* src_file_name);
static inline uint8_t prg_read_byte     (program_t *prg, size_t *pc);
static inline double  prg_read_double   (program_t *prg, size_t *pc);
static inline void    construct_argument(program_t *prg, size_t *pc, uint8_t arg_mask, char* arg_buf);

int main(int argc, char* argv[])
{
    char* src_file_name = "src.assm";
    char* prg_name      = NULL;
    if (argc < 2)
    {
        printf("Usage: disassm <input program file> [<output source file>]\n");
        return 0;
    }
    if (argc >= 2)
        prg_name      = argv[1];
    if (argc >= 3)
        src_file_name = argv[2];

    program_t *prg = load_program_from_file(prg_name);
    if (__lerrno == LERR_VERSION_MISMATCH)
    {
        printf("Disassm error: program version is different from toolchain version\n");
        return 0;
    }
    else if (__lerrno != LERR_NO_ERROR)
    {
        LERRPRINT();
        return -1;
    }

    disassm(prg, src_file_name);
    program_unload(prg);

    if (__lerrno == LERR_DISASSM)
    {
        printf("Disassm error: %s\n", __lerr_str);
        return 0;
    }
    else if (__lerrno != LERR_NO_ERROR)
    {
        LERRPRINT();
        return -1;
    }
    return 0;
}

#define LISTING_SPACE 30

// INSTRUCTION definition for disassm
#define INSTRUCTION(MNEMONIC, BASE_OPCODE, ARG_TYPE, IMPL) \
case BASE_OPCODE:                                          \
{                                                          \
    /* write disasm */                                     \
    int char_cnt = 0;                                      \
    char_cnt += fprintf(disassm_file, #MNEMONIC);          \
    if (arg_mask != ARG_NONE)                              \
    {                                                      \
        char arg_buf[MAX_ARG_SIZE + 1] = {0};              \
        construct_argument(prg, &pc, arg_mask, arg_buf);   \
        if (__lerrno != LERR_NO_ERROR)                     \
        {                                                  \
            fclose(disassm_file);                          \
            return;                                        \
        }                                                  \
        char_cnt += fprintf(disassm_file, " %s", arg_buf); \
    }                                                      \
    /* write listing */                                    \
    for (int i = 0; i < LISTING_SPACE - char_cnt; i++)     \
        fprintf(disassm_file, " ");                        \
    fprintf(disassm_file, "; %04zu | ", old_pc);           \
    for (size_t i = old_pc; i < pc; i++)                   \
        fprintf(disassm_file, "%02x ", prg->code[i]);      \
    fprintf(disassm_file, "\n");                           \
}                                                          \
break;

static inline void disassm(program_t *prg, const char* src_file_name)
{
    __lerrno = LERR_NO_ERROR;

    FILE *disassm_file = fopen(src_file_name, "w");
    if (disassm_file == NULL)
    {
        LERR(LERR_FILE_IO, "Can't open output file");
        return;
    }

    fprintf(disassm_file,
            "; Auto-generated by disassm\n"
            "; Program %s\n"
            ";                             ; offs | hex\n",
            prg->prg_header->program_name);

    size_t pc = 0, old_pc = 0;
    while (pc < prg->prg_header->code_size)
    {
        old_pc = pc;
        uint8_t opcode = prg_read_byte(prg, &pc);
        if (__lerrno != LERR_NO_ERROR)
            return;

        uint8_t arg_mask = opcode & OPCODE_ARG_MASK;

        switch (opcode & OPCODE_INSTRUCTION_MASK)
        {
        #include "../cpu_def.h"

        default:
            LERR(LERR_DISASSM, "unknown base opcode %02x at offset %zu",
                                opcode & OPCODE_INSTRUCTION_MASK, old_pc);
            fclose(disassm_file);
            return;
        }
    }
    fclose(disassm_file);
}

static inline uint8_t prg_read_byte(program_t *prg, size_t *pc)
{ 
    __lerrno = LERR_NO_ERROR;
    if (*pc >= prg->prg_header->code_size)
    {
        LERR(LERR_DISASSM, "program counter out of range");
        return 0;
    }
    return prg->code[(*pc)++];
}

static inline double prg_read_double(program_t *prg, size_t *pc)
{
    __lerrno = LERR_NO_ERROR;
    if (*pc >= prg->prg_header->code_size)
    {
        LERR(LERR_DISASSM, "program counter out of range");
        return 0;
    }

    double to_ret = 0;
    memcpy(&to_ret, &prg->code[*pc], IMM_SIZE);
    (*pc) += IMM_SIZE;
    return to_ret;
}

static void construct_argument(program_t *prg, size_t *pc, uint8_t arg_mask, char* arg_buf)
{
    if ((arg_mask & ARG_MASK_RAM) != 0)
        strcat(arg_buf, "[");
    if ((arg_mask & ARG_MASK_REGISTER) != 0)
    {
        char reg_name[] = "r_x";
        reg_name[1] = 'a' + prg_read_byte(prg, pc);
        if (__lerrno != LERR_NO_ERROR)
            return;
        strcat(arg_buf, reg_name);
    }
    if ((arg_mask & ARG_MASK_REGISTER) != 0 && (arg_mask & ARG_MASK_IMMEDIATE) != 0)
        strcat(arg_buf, "+");
    if ((arg_mask & ARG_MASK_IMMEDIATE) != 0)
    {
        char num_buf[MAX_ARG_SIZE + 1] = {0};
        double imm_val = prg_read_double(prg, pc);
        if (__lerrno != LERR_NO_ERROR)
            return;
        num_to_str(imm_val, num_buf);
        strcat(arg_buf, num_buf);
    }
    if ((arg_mask & ARG_MASK_RAM) != 0)
        strcat(arg_buf, "]");
}