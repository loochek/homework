#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

#include "../common/headers/lerror.h"
#include "../common/headers/prg.h"
#include "../common/headers/arithm.h"
#include "../common/headers/global_constants.h"

static inline uint8_t prg_read_byte(size_t *pc, program_t *prg);
static inline double prg_read_double(size_t *pc, program_t *prg);
static void construct_argument(uint8_t arg_mask, size_t *pc, char* arg_buf, program_t *prg);

#define LISTING_SPACE 30

// INSTRUCTION definition for disassm
#define INSTRUCTION(MNEMONIC, BASE_OPCODE, ARG_TYPE, IMPL) \
case BASE_OPCODE:                                          \
{                                                          \
    int char_cnt = 0;                                      \
    char_cnt += fprintf(disassm_file, #MNEMONIC);          \
    if (arg_mask != ARG_NONE)                              \
    {                                                      \
        char arg_buf[MAX_ARG_SIZE + 1] = {0};              \
        construct_argument(arg_mask, &pc, arg_buf, prg);   \
        char_cnt += fprintf(disassm_file, " %s", arg_buf); \
    }                                                      \
    for (int i = 0; i < LISTING_SPACE - char_cnt; i++)     \
        fprintf(disassm_file, " ");                        \
    fprintf(disassm_file, "; %04zu  ", old_pc);            \
    for (size_t i = old_pc; i < pc; i++)                   \
        fprintf(disassm_file, "%02x ", prg->code[i]);      \
    fprintf(disassm_file, "\n");                           \
}                                                          \
break;

int disassm(const char* prg_name, const char* src_file_name)
{
    program_t *prg = load_program_from_file(prg_name);
    if (prg == NULL)
    {
        LERRPRINT();
        return -1;
    }
    
    FILE *disassm_file = fopen(src_file_name, "w");
    if (disassm_file == NULL)
    {
        fprintf(stderr, "Can't open output file\n");
        return -1;
    }

    fprintf(disassm_file, "; Auto-generated by disassm\n"
                          "; Program %s\n"
                          ";                               offs  hex\n", prg->prg_header->program_name);

    size_t pc = 0, old_pc = 0;
    while (pc < prg->prg_header->code_size)
    {
        old_pc = pc;
        uint8_t opcode = prg_read_byte(&pc, prg);
        uint8_t arg_mask = opcode & 7;

        switch (opcode & 248) // 11111000 - base opcode mask
        {
        #include "../cpu_def.h"

        default:
            printf("Disassm fatal error: unknown base opcode %02x\n", opcode & 248);
            fclose(disassm_file);
            program_unload(prg);
            return 0;
        }
    }
    fclose(disassm_file);
    program_unload(prg);
}

int main(int argc, char* argv[])
{
    char* src_file_name = "src.assm";
    char* prg_name      = NULL;
    if (argc < 2)
    {
        printf("Usage: disassm <input program file> [<output source file>]\n");
        return 0;
    }
    if (argc >= 2)
        prg_name      = argv[1];
    if (argc >= 3)
        src_file_name = argv[2];

    return disassm(prg_name, src_file_name);
}

static inline uint8_t prg_read_byte(size_t *pc, program_t *prg)
{ 
    return prg->code[(*pc)++];
}

static inline double prg_read_double(size_t *pc, program_t *prg)
{
    double to_ret = 0;
    memcpy(&to_ret, &prg->code[*pc], IMM_SIZE);
    (*pc) += IMM_SIZE;
    return to_ret;
}

static void construct_argument(uint8_t arg_mask, size_t *pc, char* arg_buf, program_t *prg)
{
    if ((arg_mask & ARG_MASK_RAM) != 0)
        strcat(arg_buf, "[");
    if ((arg_mask & ARG_MASK_REGISTER) != 0)
    {
        char reg_name[] = "r_x";
        reg_name[1] = 'a' + prg_read_byte(pc, prg);
        strcat(arg_buf, reg_name);
    }
    if ((arg_mask & ARG_MASK_REGISTER) != 0 && (arg_mask & ARG_MASK_IMMEDIATE) != 0)
        strcat(arg_buf, "+");
    if ((arg_mask & ARG_MASK_IMMEDIATE) != 0)
    {
        char num_buf[MAX_ARG_SIZE + 1] = {0};
        num_to_str(prg_read_double(pc, prg), num_buf);
        strcat(arg_buf, num_buf);
    }
    if ((arg_mask & ARG_MASK_RAM) != 0)
        strcat(arg_buf, "]");
}